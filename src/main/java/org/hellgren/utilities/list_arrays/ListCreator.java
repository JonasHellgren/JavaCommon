package org.hellgren.utilities.list_arrays;

import org.hellgren.utilities.math.MyMathUtils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.DoubleStream;
import java.util.stream.Stream;

/**
 * A utility class for creating lists of doubles with various properties.
 */
public class ListCreator {

    public static final double TOL = 1e-10;

    private ListCreator() {
    }

    /**
     * Creates a list of doubles with the specified length, all initialized to 0.
     *
     * @param len the length of the list to create
     * @return a list of doubles with the specified length, all initialized to 0
     */
    public static List<Double> createListWithZeroElements(int len) {
        // Delegate to createListWithEqualElementValues with value 0
        return createListWithEqualElementValues(len, 0);
    }

    /**
     * Creates a list of doubles with the specified length, all initialized to the specified value.
     *
     * @param len   the length of the list to create
     * @param value the value to initialize all elements to
     * @return a list of doubles with the specified length, all initialized to the specified value
     */
    public static List<Double> createListWithEqualElementValues(int len, double value) {
        // Use Collections.nCopies to create a list with the specified length and value
        return new ArrayList<>(Collections.nCopies(len, value));
    }

    /**
     * Creates a list of doubles starting from the specified start value, incrementing by the specified step,
     * and ending at or below the specified end value.
     *
     * @param start the starting value of the list
     * @param end   the ending value of the list (inclusive)
     * @param step0  the increment between each element
     * @return a list of doubles starting from the specified start value, incrementing by the specified step,
     * and ending at or below the specified end value
     */
    public static List<Double> createFromStartToEndWithStep(double start, double end, double step0) {
        // Use DoubleStream.iterate to generate the sequence of values
        double step= (step0>0) ? step0 -TOL : step0+TOL;
        return  DoubleStream.iterate(start, d -> step > 0 ? d <= end : d >= end, d -> d + step)
                .boxed()
                .toList();
    }

    /**
     * Creates a list of doubles starting from the specified start value, incrementing by the specified step,
     * and containing the specified number of elements.
     *
     * @param start    the starting value of the list
     * @param step     the increment between each element
     * @param nItems   the number of elements to generate
     * @return a list of doubles starting from the specified start value, incrementing by the specified step,
     * and containing the specified number of elements
     */
    public static List<Double> createFromStartWithStepWithNofItems(double start, double step, int nItems) {
        // Use Stream.iterate to generate the sequence of values
        return Stream.iterate(start, value -> value + step) // Start with 'start' and add 'step' for each subsequent element
                .limit(nItems)                        // Limit the sequence to 'nItems' elements
                .toList();
    }

    /**
     * Creates a list of doubles starting from the specified start value,
     * ending at the specified end value, and containing the specified number of elements.
     *
     * The list is generated by dividing the range between start and end into nItems - 1 equal parts.
     *
     * @param start    the starting value of the list
     * @param end      the ending value of the list (inclusive)
     * @param nItems   the number of elements to generate
     * @return a list of doubles starting from the specified start value,
     *         ending at the specified end value, and containing the specified number of elements
     */
    public static List<Double> createFromStartToEndWithNofItems(double start, double end, int nItems) {
        if (nItems == 0) {
            return Collections.emptyList();
        }
        if (nItems == 1) {
            return List.of(start);
        }

        double step = (end - start) / (nItems - 1);

        if (MyMathUtils.isZero(step)) {
            return createListWithEqualElementValues(nItems,start);
        }
        return createFromStartToEndWithStep(start, end, step);
    }

    /**
     * Creates a list of doubles starting from 0 and ending at nItems-1,
     * containing the specified number of elements.
     *
     * This method is a convenience wrapper around createFromStartToEndWithNofItems.
     *
     * @param nItems the number of elements to generate
     * @return a list of doubles starting from 0 and ending at nItems-1
     */
    public static List<Double> createFromZeroToNofItems(int nItems) {
        return createFromStartToEndWithNofItems(0, nItems-1d, nItems);
    }


        /**
         * Creates a list of integers starting from the specified start value, incrementing by the specified step,
         * and containing the specified number of elements.
         *
         * @param start    the starting value of the list
         * @param step     the increment between each element
         * @param nItems   the number of elements to generate
         * @return a list of integers starting from the specified start value, incrementing by the specified step,
         *         and containing the specified number of elements
         */
    public static List<Integer> createFromStartWithStepWithNofItems(int start, int step, int nItems) {
        if (nItems == 0) {
            return Collections.emptyList();
        }
        if (nItems == 1) {
            return List.of(start);
        }
        List<Integer> result = new ArrayList<>();
        for (int i = 0; i < nItems; i++) {
            result.add(start + (i * step));
        }
        return result;
    }

    /**
     * Creates a mutable list containing 'n' copies of the specified element.
     *
     * @param <T> the type of the element to be copied
     * @param x   the element to be copied
     * @param n   the number of copies to create
     * @return a mutable list containing 'n' copies of the specified element
     */

    public static <T> List<T> nCopiesMutable(T x, int n) {
        List<T> result = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            result.add(x);
        }
        return result;
    }

    /**
     * Returns an empty list of Doubles.
     *
     * @return an empty ArrayList of Doubles
     */
    public static List<Double> emptyDouble() {
        return new ArrayList<>();
    }

    /**
     * Creates a list representing a one-hot encoding with the specified number of inputs and hot index.
     *
     * @param nofInputs the total number of inputs in the one-hot encoding
     * @param hotIndex  the index of the hot element (i.e., the element with value 1.0)
     * @return a list of doubles representing the one-hot encoding
     */
    public static List<Double> createListWithOneHot(int nofInputs, int hotIndex) {
        return createListWithOneHotWithValue(nofInputs, hotIndex, 1d);
    }

    /**
     * Creates a list representing a one-hot encoding with the specified number of inputs, hot index, and value.
     *
     * @param nofInputs the total number of inputs in the one-hot encoding
     * @param hotIndex  the index of the hot element
     * @param v         the value of the hot element
     * @return a list of doubles representing the one-hot encoding
     */
    public static List<Double> createListWithOneHotWithValue(int nofInputs, int hotIndex, double v) {
        List<Double> onHot = ListCreator.createListWithEqualElementValues(nofInputs, 0d);
        onHot.set(hotIndex, v);
        return onHot;
    }

}